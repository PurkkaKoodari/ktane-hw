from abc import ABC, abstractmethod
from enum import Enum
from threading import RLock, Condition
from time import sleep

from .bus.bus import BombBus
from .bus.messages import BusMessage, ResetMessage, AnnounceMessage, InitializeMessage, InitCompleteMessage, DefuseBombMessage, ExplodeBombMessage, ModuleId
from .modules.registry import MODULE_ID_REGISTRY
from .modules.base import ModuleState
from .modules.timer import TimerModule
from .utils import EventSource

class TimerTick:
    """The event raised when the bomb timer ticks."""

class BombWarning:
    """The event raised when a warning-level message is generated by the bomb."""

    __slots__ = ("reason", "module")

    def __init__(self, reason: str, module: ModuleId = None):
        self.reason = reason
        self.module = module

class BombInitFailure:
    """The event raised when the bomb initialization fails."""

    __slots__ = ("reason",)

    def __init__(self, reason: str):
        self.reason = reason

class Casing(ABC):
    """
    The base class for the bomb casings.
    """

    @abstractmethod
    def capacity(self) -> int:
        pass

    @abstractmethod
    def location(self, index: int) -> str:
        pass

class VanillaCasing(Casing):
    """
    The bomb casing in the vanilla game.
    """

    def capacity(self) -> int:
        return 12

    def location(self, index: int) -> str:
        if not 0 <= index < 12:
            raise ValueError("index must be between 0 and 11")
        return f"{'front' if index < 6 else f'back'} side, row {index // 3 % 2 + 1}, column {index % 3}"

class BombState(Enum):
    UNINITIALIZED = 0
    WAITING_FOR_MODULES = 1
    INITIALIZING_MODULES = 2
    MODULES_INITIALIZED = 3
    INITIALIZATION_FAILED = -1

class Bomb(EventSource):
    """
    The bomb, consisting of a casing and modules.
    """

    DEFAULT_MAX_STRIKES = 3

    def __init__(self, bus: BombBus, *, max_strikes=DEFAULT_MAX_STRIKES, casing=None):
        super().__init__()
        self._bus = bus
        self.casing = casing or VanillaCasing()
        self.modules_by_bus_id = {}
        self.modules_by_position = {}
        self.max_strikes = max_strikes
        self.strikes = 0
        self._state = BombState.UNINITIALIZED
        self._state_lock = RLock()
        self._init_cond = Condition(self._state_lock)
        bus.add_listener(BusMessage, self._receive_message)
        self.add_listener(BombInitFailure, self._init_fail)

    def _init_fail(self, _1, _2):
        with self._state_lock:
            self._state = BombState.INITIALIZATION_FAILED

    def initialize(self):
        with self._state_lock:
            self._state = BombState.WAITING_FOR_MODULES
            self._bus.send(ResetMessage(ModuleId.BROADCAST))
        sleep(1)
        with self._state_lock:
            if self._state == BombState.INITIALIZATION_FAILED:
                return
            self._state = BombState.INITIALIZING_MODULES
        if not any(isinstance(module, TimerModule) for module in self.modules_by_bus_id.values()):
            self.trigger(BombInitFailure("no timer found on bomb"))
            return
        for module in self.modules_by_bus_id.values():
            module.state = ModuleState.INITIALIZATION
            self._bus.send(InitializeMessage(module.bus_id, hw_version=(0, 0), sw_version=(0, 0))) # TODO get version numbers
            location = 0 # TODO wait for physical location via GPIO or fail if didn't get a signal
            module.location = location
        with self._state_lock:
            self._init_cond.wait_for(lambda: self._state == BombState.MODULES_INITIALIZED) # TODO cancellation mechanism

    def _receive_message(self, _, message: BusMessage):
        if self._state == BombState.UNINITIALIZED:
            return
        if isinstance(message, AnnounceMessage):
            if self._state == BombState.WAITING_FOR_MODULES:
                if message.module in self.modules_by_bus_id:
                    self.trigger(BombInitFailure(f"duplicate module with id {message.module}"))
                    return
                self.modules_by_bus_id[message.module] = MODULE_ID_REGISTRY[message.module.type](self, message.module)
                return
            self.trigger(BombWarning(f"module {message.module} announced too late and was not initialized"))
        if isinstance(message, InitCompleteMessage) and self._state == BombState.INITIALIZING_MODULES:
            module = self.modules_by_bus_id.get(message.module)
            if module is not None and module.state == ModuleState.INITIALIZATION:
                module.state = ModuleState.CONFIGURATION
                if all(module.state == ModuleState.CONFIGURATION for module in self.modules_by_bus_id.values()):
                    with self._state_lock:
                        self._state = BombState.MODULES_INITIALIZED
                return
        # TODO whole bunch of other messages
        self.trigger(BombWarning(f"{message.__class__.__name__} received from {message.module} in an invalid state"))

    def explode(self):
        self._bus.send(ExplodeBombMessage(ModuleId.BROADCAST))

    def defuse(self):
        self._bus.send(DefuseBombMessage(ModuleId.BROADCAST))

    def strike(self) -> bool:
        """Increments the strike count. Returns True if the bomb exploded."""
        self.strikes += 1
        if self.strikes >= self.max_strikes:
            self.explode()
            return True
        return False
